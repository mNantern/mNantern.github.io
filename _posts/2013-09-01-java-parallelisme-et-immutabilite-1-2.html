---
layout: post
title: Java - Parallélisme et Immutabilité 1/2
date: 2013-09-01
comments: false
categories: fr
excerpt: Première partie d'une série sur le parallélisme et l'immutabilité dans Java.
---

<div class='post'>
<div class="separator" style="clear: both; text-align: center;"><a href="{{site.url}}/assets/javacode-908579.jpeg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="320" src="{{site.url}}/assets/javacode-908579.jpeg" width="400" /></a></div><br /><br />Ces derniers temps j'ai passé pas mal d'entretiens en Java et je me suis rendu compte qu'il s'agissait toujours des même questions qui revenaient.<br />Voici donc une petite série sur les questions les plus classiques et comment y répondre.<br />Pour débuter nous allons parler de parallélisme et d'immutabilité un sujet très classique dans les entretiens.<br /><br />Souvent le sujet sera introduit de la manière suivante:<br /><br /><h2>Vous voulez paralléliser votre code, comment faites-vous ?</h2>Réponse simple et efficace: en utilisant des threads. Et à partir de là ça se gâte en général !<br /><br /><h2>A quoi faut-il faire attention lors de l'utilisation des Threads ?</h2>Le code utilisé avec des Threads doit être "Thread-Safe" afin d'éviter des incohérences dans le résultat du code.<br />En particulier lors de l'écriture et de la lecture de valeurs il arrive bien souvent que l'on tombe sur des incohérences telles que:<br /><ol start="1" type="1"><li>La valeur lue n'est pas la dernière valeur écrite en mémoire. Cela est du au fait que les threads disposent de leur propre cache et ne le synchronise pas forcément avec la mémoire centrale où est stockée la valeur.</li><li>La valeur écrite par un Thread est écrasée par un autre.</li></ol>Voici un exemple de code pouvant éventuellement (cela dépend beaucoup de la machine, de la JVM et de l'OS) montrer le problème 1:<br /><br /><br /><script src="https://gist.github.com/mNantern/6405389.js"></script> <b>Résultat:</b> Le script ne se termine jamais car le thread ne voit pas que le champ keepRunning vient de passer à false<br /><br /><br />Et un autre pour le cas 2:<br /><br /><br /><script src="https://gist.github.com/mNantern/6406682.js"></script> <b>Résultat:</b> <br /><br /><br /><script src="https://gist.github.com/mNantern/6406698.js"></script> On voit que le thread 1 se lance et fait ses 10 boucles sans aucun problème.<br />A la fin de son exécution count vaut 10 ce qui est normal.<br /><br />Malheureusement le thread 2 ne prend pas la suite car il a déjà démarré il y a quelques temps a récupéré la valeur de count qui valait alors 0 mais n'a pu faire son incrément qu'à la fin de l'exécution du thread 1.<br /><br />Contrairement à ce qu'on pourrait croire l'opération "count++" n'est pas atomique, il s'agit d'une lecture puis d'une écriture dans le champ count.<br /><br />Dans le cas présent le thread 2 a pu lire mais pas écrire la valeur dans count. Il ne le fait qu'à la toute fin de la boucle de t1. En fait il écrit sa valeur juste avant que t1 n'écrive "10" dans count.<br />Cela explique pourquoi t2 continue avec 11 au lieu de 2 s'il avait écrit après la fin de t1.<br /><br />Dans tous les cas il n'a pu incrémenter correctement count et cela se voit sur le résultat final avec un count valant 19 au lieu de 20 si tout s'était déroulé normalement.<br /><br /><br /><h2>Comment éviter le problème de rafraîchissement de cache d'un Thread ?</h2>Dans le cas présenté ci-dessus notre paramètre "keepRunning" est un paramètre servant à contrôler la fin d'une boucle. Typiquement dans ce cas le plus simple est d'utiliser le mot clé "synchronized".<br /><br />Pour faire simple ce mot clé permet d'indiquer à la JVM que le champ concerné sera accédé par différents threads et donc de stocker cette valeur dans la mémoire centrale et non dans le cache de chacun des threads.<br /><br />Le cas d'utilisation typique est de mettre à jour un flag dans un thread et de le lire dans un autre:<br /><br /><br /><script src="https://gist.github.com/mNantern/6405397.js"></script><br /><br /><br />Ce mot clé ne permet pas de résoudre le problème n°2 car il ne rend atomique que le get et le set et pas une combinaison des deux (ce qu'est le "count++").<br /><br />Il n'est pas pertinent non plus d'utiliser le mot clé volatile dans certains cas:<br /><ul><li>Le champ est déclaré "final" (voir la seconde partie sur l'immutabilité)</li><li>Le champ n'est accédé que par un seul thread</li><li>Le champ doit être protégé pour des accès complexes (comme dans notre exemple n°2).</li></ul><h2>Comment éviter le problème d'écrasement d'une valeur par un autre thread ?</h2><br />La façon la plus simple d'éviter le problème n°2 est d'utiliser le mot clé "<b>synchronized</b>" qui permet de limiter l'exécution d'un bloc de code à un seul thread à la fois:<br /><br /><br /><script src="https://gist.github.com/mNantern/6406771.js"></script><br /><br /><br />Le problème de l'utilisation du mot clé synchronized est qu'il induit un lock bloquant les autres threads ce qui est mauvais pour les performances et la scalabilité car il constitue un véritable goulet d'étranglement limitant le passage à un seul Thread à la fois.<br /><br /><br />Une autre solution est de n'échanger entre les threads que des <b>objets immutables </b>qui évitent les locks et permettent d'obtenir des résultats corrects. <br /><br />Mais ça on le verra dans la seconde partie de l'article qui arrive bientôt ! (... :)<br /><br /><br />Post 12/52<br /><br /></div>
